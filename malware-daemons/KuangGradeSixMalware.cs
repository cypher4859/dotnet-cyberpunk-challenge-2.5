using System;
using System.Collections.Generic;
using System.Linq;
using System.Threading.Tasks;
using dotnet_cyberpunk_challenge_2._5.malware_daemons.lib;

namespace dotnet_cyberpunk_challenge_2._5.malware_daemons
{
    public class KuangGradeSixMalware : KuangDaemonFamilyBase
    {
        // Objective: We need a variant of the Kuang malware that specifically is able to do some basic recon
        // We're not too concerned about breaking ice. We plan to use this on auxiliary systems to collect data
        // for later penetrations. The main thing we need FROM YOU is to add some functionality to:
        //  1. Get the process list
        //  2. Get the memory mapping of a given process

        /*TODO: Go ahead and create a constructor just in case. 
        It's gonna be empty but maybe we'll add stuff to it later
        */
        public KuangGradeSixMalware() {
        }

        /*TODO: Go ahead and create a public function called Initialize()
            - This will be a public function
            - It'll be an async function (because inside the function needs to use `await` when making a network request)
            - It needs to return Task datatype because it's an async function
            - It needs to call a method in the base class to Get the Current Arasaka Connection 
            with no arguments passed to it
            - When we call the method to get the connection we need to add the `await` keyword before it
            so that C# knows to wait until the network is complete. Otherwise your program will get all 
            jumbled and try to continue executing before the connection request is complete. E.g. `await SomeMethod();`
            - *Optional* If you want to you can make a variable to assign/bind the object returned from that method,
            the datatype will be an ArasakaServerConnection.
        */
        public async Task Initialize() {
            ArasakaServerConnection connection = await GetCurrentArasakaConnection();
        }


        /*TODO: We need to make a public function called GetProcessList()
            - This will be a public function
            - It'll be an async function (because inside the function needs to use `await` when making a network request)
            - It needs to return `Task` datatype because it's an async function
            - It needs to call the `SendRequest()` method on the `CurrentServerConnection` property. It will pass
            a single string argument of `"process-list"` to the method.
            - Before the property + method call we need to use the `await` keyword before it
            so that C# knows to wait until the network is complete. Otherwise your program will get all 
            jumbled and try to continue executing before the connection request is complete.
            - make a variable to assign/bind the object returned from that method,
            the datatype will be an ArasakaMessageResponse. You'll have to F12 into the class to see
            what properties are on it. *NOTE*: Use the comments/docs on the class to know what keys you
            can reference on the Dictionary properties in that datatype
            - You'll need to access the `content` key on the ArasakaMessageResponse object you get back and
            access the dictionary key ["processList"]. This will give you an array of dictionaries, i.e. the list of running processes. 
            You will then need loop over that array of processes and access/print out the following keys from the each item in that array.
                1. "processId"
                2. "memory"
                3. "family"
                4. "openFiles"
            - TIP: Something that helps me is to get the response object back and stored into a variable, set a breakpoint, run in debug mode,
            and make sure to pause execution right after the response is bound to a variable and look at how the data is structured. In this 
            way you can see at runtime the structure of the data and type out the code for how to you need to process the data, then 
            save changes + restart the app and make sure your processing works.
        */
        public async Task GetProcessList() {
            ArasakaMessageResponse response = await CurrentServerConnection.SendRequest("process-list");
            string processList = response.content["processList"];
            IEnumerable<string> cleanedProcessList = Helpers.JsonToDictionary(processList);
        }


        /*TODO: The base class has a number of abstract methods. You can simply implement those methods
        with the exact same signature (except with the "override" keyword instead of abstract).
        The body of the overridden methods can either be "throw new NotImplementedException()" or whatever
        behavior you come up with. The world is your oyster :)
        */
        public override Task<ArasakaMessageResponse> GetIceTypeOnRemote()
        {
            throw new NotImplementedException();
        }

        public override void IceBreak()
        {
            throw new NotImplementedException();
        }

        public override Task SetupIceBreakerTunnelToTarget()
        {
            throw new NotImplementedException();
        }
    }
}