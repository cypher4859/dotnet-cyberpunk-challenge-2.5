using System;
using System.Collections.Generic;
using System.Linq;
using System.Threading.Tasks;
using dotnet_cyberpunk_challenge_2._5.malware_daemons.lib;

namespace dotnet_cyberpunk_challenge_2._5.malware_daemons
{
    public class KuangGradeSixMalware : KuangDaemonFamilyBase
    {
        // Objective: We need a variant of the Kuang malware that specifically is able to do some basic recon
        // We're not too concerned about breaking ice. We plan to use this on auxiliary systems to collect data
        // for later penetrations. The main thing we need FROM YOU is to add some functionality to:
        //  0. Initialize the malware
        //  1. Get the process list. We can use this list to get the memory mappings of the given process
        //  2. Get the memory mapping of a given process

        /*TODO: Go ahead and create a constructor just in case. 
        It's gonna be empty but maybe we'll add stuff to it later.
        It should be public.
        */

        /*TODO: Go ahead and create a public function called Initialize()
            - This will be a public function
            - It'll be an async function (because inside the function needs to use `await` when making a network request).
            *hint*: This keyword goes in-between the access-modifier and the return type
            - It needs to return `Task` datatype because it's an async function. 
            Examples on usage: If you wanted to return a string from an async
            function then you would set the return type to `Task<string>`. If you wanted to return a list of strings then
            you would use `Task<List<string>>`.
            - This method needs be to called `Initialize()`
            - In the definition this methods needs to call a method in the base class to Get the Current Arasaka Connection 
            with no arguments passed to it.
            - *NOTE: When we call the method to get the connection we need to add the `await` keyword before it (ex. is below)
            so that C# knows to wait until the network connection (e.g. HTTP request) is complete. 
            Otherwise your program will get all jumbled and try to continue executing before the 
            connection request is complete; in this case you'll notice that execution just *stops* suddenly without warning, 
            even in debug mode. E.g. `await SomeMethod();`
            - *Optional* If you want to you can make a variable to assign/bind the object returned from that method,
            the datatype will be an ArasakaServerConnection. You don't need to do this but you can; For details on why you don't
            need to do so, please check out the definition of the method.
        */
        public async Task Initialize() {
            ArasakaServerConnection connection = await GetCurrentArasakaConnection();
        }


        /*TODO: We need to make a public function called GetProcessList()
            - This will be a public function
            - It'll be an async function (because inside the function needs to use `await` when making a network request)
            - It needs to return `Task` datatype because it's an async function
            - It needs to call the `SendRequest()` method on the `CurrentServerConnection` property. It will pass
            a single string argument of `"process-list"` to the method.
            - Before the property + method call we need to use the `await` keyword before it
            so that C# knows to wait until the network is complete. Otherwise your program will get all 
            jumbled and try to continue executing before the connection request is complete.
            - make a variable to assign/bind the object returned from that method,
            the datatype will be an ArasakaMessageResponse. You'll have to F12 into the class to see
            what properties are on it. *NOTE*: Use the comments/docs on the class to know what keys you
            can reference on the Dictionary properties in that datatype
            - You'll need to access the `content` key on the ArasakaMessageResponse object you get back and
            access the dictionary key ["processList"]. This will give you an array of dictionaries, i.e. the list of running processes. 
            You will then need loop over that array of processes and access/print out the following keys from the each item in that array.
                1. "processId"
                2. "memory"
                3. "family"
                4. "openFiles"
            - TIP: Something that helps me is to get the response object back and stored into a variable, set a breakpoint, run in debug mode,
            and make sure to pause execution right after the response is bound to a variable and look at how the data is structured. In this 
            way you can see at runtime the structure of the data and type out the code for how to you need to process the data, then 
            save changes + restart the app and make sure your processing works.
        */


        /*TODO: The base class has a number of abstract methods. You can simply implement those methods
        with the exact same signature (except: use the "override" keyword instead of abstract).
        The body of the overridden methods can either be "throw new NotImplementedException()" or whatever
        behavior you come up with. The world is your oyster :)
        */
    }
}